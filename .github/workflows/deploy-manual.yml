name: üöÄ Manual Deploy to Production

# Faqat qo'lda ishga tushadigan workflow
# GitHub'da Actions tabidan "Run workflow" tugmasini bosib ishlatiladi
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deploy environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      run_migrations:
        description: 'Run database migrations?'
        required: true
        default: 'yes'
        type: choice
        options:
          - yes
          - no
      run_seeds:
        description: 'Run database seeds?'
        required: false
        default: 'no'
        type: choice
        options:
          - yes
          - no

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: üì¶ Create deployment package
        run: |
          echo "Creating deployment package..."
          tar -czf deploy-package.tar.gz \
            --exclude=node_modules \
            --exclude=dist \
            --exclude=.git \
            --exclude=uploads \
            .

      - name: üöÄ Deploy to server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST || '172.22.0.19' }}
          SERVER_USER: ${{ secrets.SERVER_USER || 'root' }}
          DEPLOY_PATH: /var/www/auth-api
        run: |
          echo "üåê Connecting to $SERVER_USER@$SERVER_HOST..."

          # Add server to known hosts
          ssh-keyscan -H $SERVER_HOST >> ~/.ssh/known_hosts

          # Upload deployment package
          echo "üì§ Uploading files..."
          scp deploy-package.tar.gz $SERVER_USER@$SERVER_HOST:$DEPLOY_PATH/

          # Execute deployment on server
          ssh $SERVER_USER@$SERVER_HOST << 'ENDSSH'
            set -e
            cd /var/www/auth-api
            
            echo "üîÑ Extracting files..."
            tar -xzf deploy-package.tar.gz
            rm deploy-package.tar.gz
            
            echo "üíæ Creating backup..."
            mkdir -p backups
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            docker-compose -f docker-compose.prod.yml exec -T mysql mysqldump \
              -u root -p${MYSQL_ROOT_PASSWORD} ${DB_NAME} > "backups/db_backup_$TIMESTAMP.sql" 2>/dev/null || \
              echo "‚ö†Ô∏è  Database backup skipped"
            
            echo "üî® Building containers..."
            docker-compose -f docker-compose.prod.yml up -d --build
            
            echo "‚è≥ Waiting for API to be ready..."
            sleep 15
            
            # Health check
            MAX_RETRIES=30
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker-compose -f docker-compose.prod.yml exec -T api wget -q -O- http://localhost:3000/health > /dev/null 2>&1; then
                echo "‚úÖ API is healthy!"
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT+1))
              echo "Waiting... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 2
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "‚ùå Health check failed!"
              docker-compose -f docker-compose.prod.yml logs --tail=50 api
              exit 1
            fi
          ENDSSH

      - name: üóÑÔ∏è Run database migrations
        if: inputs.run_migrations == 'yes'
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST || '172.22.0.19' }}
          SERVER_USER: ${{ secrets.SERVER_USER || 'root' }}
        run: |
          echo "üóÑÔ∏è  Running database migrations..."
          ssh $SERVER_USER@$SERVER_HOST << 'ENDSSH'
            cd /var/www/auth-api
            docker-compose -f docker-compose.prod.yml exec -T api npm run migration:run
            echo "‚úÖ Migrations completed!"
          ENDSSH

      - name: üå± Run database seeds
        if: inputs.run_seeds == 'yes'
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST || '172.22.0.19' }}
          SERVER_USER: ${{ secrets.SERVER_USER || 'root' }}
        run: |
          echo "üå± Running database seeds..."
          ssh $SERVER_USER@$SERVER_HOST << 'ENDSSH'
            cd /var/www/auth-api
            docker-compose -f docker-compose.prod.yml exec -T api npm run seed
            echo "‚úÖ Seeds completed!"
          ENDSSH

      - name: üîç Health check
        env:
          APP_URL: ${{ secrets.APP_URL || 'https://auth.uzswlu.uz' }}
        run: |
          echo "üîç Checking application health..."
          sleep 5

          HEALTH_CHECK=$(curl -s -o /dev/null -w "%{http_code}" $APP_URL/health || echo "000")

          if [ "$HEALTH_CHECK" = "200" ]; then
            echo "‚úÖ Application is healthy!"
            echo "üåê URL: $APP_URL"
          else
            echo "‚ö†Ô∏è  Health check returned: $HEALTH_CHECK"
            echo "Application might still be starting up..."
          fi

      - name: üìä Show deployment info
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST || '172.22.0.19' }}
          SERVER_USER: ${{ secrets.SERVER_USER || 'root' }}
        run: |
          echo "üìä Deployment Information:"
          ssh $SERVER_USER@$SERVER_HOST << 'ENDSSH'
            cd /var/www/auth-api
            echo "Container Status:"
            docker-compose -f docker-compose.prod.yml ps
            
            echo ""
            echo "Recent Logs:"
            docker-compose -f docker-compose.prod.yml logs --tail=20 api
          ENDSSH

      - name: üéâ Deployment complete
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "Environment: ${{ inputs.environment }}"
          echo "Migrations: ${{ inputs.run_migrations }}"
          echo "Seeds: ${{ inputs.run_seeds }}"
          echo "Timestamp: $(date)"
